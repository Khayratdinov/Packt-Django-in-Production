# Вопросы для самоконтроля

1. Как настроить PostgreSQL для работы с проектом Django?
2. В чем разница между параметрами `null` и `blank` в моделях Django?
3. Как использовать `OneToOneField`, `ForeignKey` и `ManyToManyField` для установления отношений между моделями?
4. Как извлечь SQL-запросы, генерируемые Django ORM?
5. Какие имеются команды для управления миграциями в Django, и как они работают?
6. Какие лучшие практики рекомендуется соблюдать при работе с моделями Django?
7. Как оптимизировать производительность запросов в Django ORM?
8. В чем преимущества использования асинхронного Django ORM, представленного в версии 4.1?

# Ответы на вопросы для самоконтроля

1. **Как настроить PostgreSQL для работы с проектом Django?**

   Для настройки PostgreSQL необходимо:

   - Создать сервер PostgreSQL (например, с помощью ElephantSQL).
   - Получить данные для подключения: `HOST`, `NAME`, `USER`, `PASSWORD`, `PORT`.
   - Установить клиентский адаптер PostgreSQL для Python:

     ```bash
     pip install psycopg2-binary
     ```

   - В файле `settings.py` обновить конфигурацию базы данных:

     ```python
     DATABASES = {
         'default': {
             'ENGINE': 'django.db.backends.postgresql',
             'HOST': '<ваш_host>',
             'NAME': '<имя_базы_данных>',
             'USER': '<пользователь>',
             'PORT': 5432,
             'PASSWORD': '<пароль>',
         }
     }
     ```

2. **В чем разница между параметрами `null` и `blank` в моделях Django?**

   - `null=True` означает, что в базе данных поле может иметь значение `NULL`. Это ограничение на уровне базы данных.
   - `blank=True` позволяет оставлять поле пустым в формах Django или админ-панели. Это ограничение на уровне валидации данных в Django.

   Использование обоих параметров позволяет базе данных принимать `NULL`, а Django — сохранять пустые значения.

3. **Как использовать `OneToOneField`, `ForeignKey` и `ManyToManyField` для установления отношений между моделями?**

   - **`OneToOneField`**: используется для отношений "один к одному".

     ```python
     class Profile(models.Model):
         user = models.OneToOneField(User, on_delete=models.CASCADE)
         bio = models.TextField()
     ```

   - **`ForeignKey`**: используется для отношений "один ко многим". 

     ```python
     class Article(models.Model):
         author = models.ForeignKey(Author, on_delete=models.CASCADE)
         title = models.CharField(max_length=100)
     ```

   - **`ManyToManyField`**: используется для отношений "многие ко многим".

     ```python
     class Student(models.Model):
         name = models.CharField(max_length=100)

     class Course(models.Model):
         students = models.ManyToManyField(Student)
     ```

4. **Как извлечь SQL-запросы, генерируемые Django ORM?**

   - Для объектов `QuerySet` можно использовать атрибут `.query`:

     ```python
     qs = Author.objects.filter(name='John')
     print(qs.query)
     ```

   - Для других случаев можно использовать `django.db.connection.queries`:

     ```python
     from django.db import connection
     Author.objects.filter(name='John').count()
     print(connection.queries[-1])
     ```

5. **Какие имеются команды для управления миграциями в Django, и как они работают?**

   - **`makemigrations`**: создает файлы миграций на основе изменений в моделях.

     ```bash
     python manage.py makemigrations
     ```

   - **`migrate`**: применяет миграции к базе данных.

     ```bash
     python manage.py migrate
     ```

   - **`sqlmigrate`**: отображает SQL-запросы для конкретной миграции.

     ```bash
     python manage.py sqlmigrate app_name migration_number
     ```

   - **`showmigrations`**: показывает состояние всех миграций.

     ```bash
     python manage.py showmigrations
     ```

6. **Какие лучшие практики рекомендуется соблюдать при работе с моделями Django?**

   - Использовать абстрактные базовые модели для общих полей.
   - Определять метод `__str__` для удобного представления объектов.
   - Избегать циклических зависимостей между моделями.
   - Использовать транзакции для атомарности операций:

     ```python
     from django.db import transaction

     with transaction.atomic():
         # ваши операции
     ```

   - Создавать пользовательские методы в моделях для повторяющейся логики.

7. **Как оптимизировать производительность запросов в Django ORM?**

   - Использовать методы `select_related` и `prefetch_related` для загрузки связанных объектов и уменьшения количества запросов к базе данных.

     ```python
     blogs = Blog.objects.select_related('author').all()
     ```

   - Применять индексы к полям, которые часто используются в фильтрах и объединениях.

     ```python
     class Author(models.Model):
         name = models.CharField(max_length=100)

         class Meta:
             indexes = [
                 models.Index(fields=['name']),
             ]
     ```

   - Использовать метод `exists()` вместо `count()` для проверки наличия записей.

     ```python
     if Blog.objects.filter(title='My Blog').exists():
         # запись существует
     ```

   - Избегать использования `bulk_create` и `bulk_update`, так как они обходят методы `save()` и могут пропустить важную логику или сигналы.

8. **В чем преимущества использования асинхронного Django ORM, представленного в версии 4.1?**

   Асинхронный Django ORM позволяет писать неблокирующий код для операций с базой данных, что улучшает производительность приложений, особенно при работе с медленными источниками данных или в высоконагруженных системах. Синтаксис аналогичен синхронному, но с использованием ключевого слова `await`:

   ```python
   async def get_blog(request):
       blog = await Blog.objects.aget(id=10)
       return JsonResponse({'title': blog.title})
   ```

   Это позволяет эффективно использовать ресурсы сервера и улучшает масштабируемость приложения.

# Темы для эссе

1. **Сравнение методов оптимизации запросов в Django ORM и их влияние на производительность приложения.**

2. **Роль и управление миграциями в командной разработке на Django: лучшие практики и потенциальные проблемы.**

3. **Использование асинхронного Django ORM: преимущества, ограничения и примеры внедрения в существующие проекты.**

4. **Глубокое погружение в отношения между моделями в Django: от простых связей до сложных структур данных.**

5. **Практическое применение транзакций в Django: обеспечение целостности данных в реальных проектах.**

# Глоссарий

1. **Django ORM (Object-Relational Mapping)**: Средство Django для взаимодействия с базой данных, позволяющее работать с данными как с объектами Python, абстрагируя SQL-запросы.

2. **Миграции**: Механизм Django для управления изменениями схемы базы данных, позволяющий отслеживать и применять изменения в моделях.

3. **`select_related` и `prefetch_related`**: Методы Django ORM для оптимизации запросов при получении связанных данных, уменьшая количество обращений к базе данных.

4. **Абстрактные базовые модели**: Модели Django, которые не создают таблиц в базе данных, но могут быть унаследованы другими моделями для повторного использования полей и методов.

5. **Индексы**: Структуры данных в базе данных, которые ускоряют поиск и выборку данных по конкретным полям.

6. **Асинхронный ORM**: Новая функция в Django 4.1, позволяющая выполнять операции с базой данных асинхронно, улучшая производительность приложений.

7. **`null` и `blank`**: Параметры полей моделей Django, контролирующие допустимость `NULL` в базе данных и возможность оставлять поле пустым при вводе данных.

8. **Транзакции**: Механизм атомарного выполнения набора операций с базой данных, гарантируя, что либо все операции будут выполнены успешно, либо ни одна из них не будет применена при ошибке.

9. **`OneToOneField`, `ForeignKey`, `ManyToManyField`**: Поля моделей Django, используемые для установления различных типов отношений между моделями.

10. **Фейковые миграции**: Метод пометки миграций как выполненных без фактического применения изменений к базе данных, полезный при синхронизации состояния базы данных и миграций.