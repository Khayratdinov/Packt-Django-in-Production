# Self-check Questions

1. How to configure PostgreSQL for use with a Django project?  
2. What is the difference between the `null` and `blank` parameters in Django models?  
3. How to use `OneToOneField`, `ForeignKey`, and `ManyToManyField` to establish relationships between models?  
4. How to extract SQL queries generated by Django ORM?  
5. What commands are available for managing migrations in Django, and how do they work?  
6. What are the best practices to follow when working with Django models?  
7. How to optimize query performance in Django ORM?  
8. What are the advantages of using Django's asynchronous ORM introduced in version 4.1?  

# Answers to Self-check Questions

1. **How to configure PostgreSQL for use with a Django project?**  

   To configure PostgreSQL:  

   - Set up a PostgreSQL server (e.g., using ElephantSQL).  
   - Obtain connection details: `HOST`, `NAME`, `USER`, `PASSWORD`, and `PORT`.  
   - Install the PostgreSQL adapter for Python:  

     ```bash
     pip install psycopg2-binary
     ```

   - Update the `DATABASES` configuration in the `settings.py` file:  

     ```python
     DATABASES = {
         'default': {
             'ENGINE': 'django.db.backends.postgresql',
             'HOST': '<your_host>',
             'NAME': '<database_name>',
             'USER': '<user>',
             'PORT': 5432,
             'PASSWORD': '<password>',
         }
     }
     ```

2. **What is the difference between the `null` and `blank` parameters in Django models?**  

   - `null=True`: Allows the database field to store `NULL` values (database-level constraint).  
   - `blank=True`: Allows the field to be left empty in Django forms or the admin panel (validation-level constraint).  

   Using both allows the database to accept `NULL` and Django to handle empty values.  

3. **How to use `OneToOneField`, `ForeignKey`, and `ManyToManyField` to establish relationships between models?**  

   - **`OneToOneField`**: Used for one-to-one relationships.  

     ```python
     class Profile(models.Model):
         user = models.OneToOneField(User, on_delete=models.CASCADE)
         bio = models.TextField()
     ```

   - **`ForeignKey`**: Used for one-to-many relationships.  

     ```python
     class Article(models.Model):
         author = models.ForeignKey(Author, on_delete=models.CASCADE)
         title = models.CharField(max_length=100)
     ```

   - **`ManyToManyField`**: Used for many-to-many relationships.  

     ```python
     class Student(models.Model):
         name = models.CharField(max_length=100)

     class Course(models.Model):
         students = models.ManyToManyField(Student)
     ```

4. **How to extract SQL queries generated by Django ORM?**  

   - For `QuerySet` objects, use the `.query` attribute:  

     ```python
     qs = Author.objects.filter(name='John')
     print(qs.query)
     ```

   - For other cases, use `django.db.connection.queries`:  

     ```python
     from django.db import connection
     Author.objects.filter(name='John').count()
     print(connection.queries[-1])
     ```

5. **What commands are available for managing migrations in Django, and how do they work?**  

   - **`makemigrations`**: Creates migration files based on model changes.  

     ```bash
     python manage.py makemigrations
     ```

   - **`migrate`**: Applies migrations to the database.  

     ```bash
     python manage.py migrate
     ```

   - **`sqlmigrate`**: Displays SQL queries for a specific migration.  

     ```bash
     python manage.py sqlmigrate app_name migration_number
     ```

   - **`showmigrations`**: Shows the status of all migrations.  

     ```bash
     python manage.py showmigrations
     ```

6. **What are the best practices to follow when working with Django models?**  

   - Use abstract base models for shared fields.  
   - Define the `__str__` method for better object representation.  
   - Avoid circular dependencies between models.  
   - Use transactions for atomic operations:  

     ```python
     from django.db import transaction

     with transaction.atomic():
         # your operations
     ```

   - Add custom methods to models for reusable logic.  

7. **How to optimize query performance in Django ORM?**  

   - Use `select_related` and `prefetch_related` to reduce the number of database queries.  

     ```python
     blogs = Blog.objects.select_related('author').all()
     ```

   - Add indexes to fields frequently used in filters or joins.  

     ```python
     class Author(models.Model):
         name = models.CharField(max_length=100)

         class Meta:
             indexes = [
                 models.Index(fields=['name']),
             ]
     ```

   - Use `exists()` instead of `count()` to check for record existence.  

     ```python
     if Blog.objects.filter(title='My Blog').exists():
         # record exists
     ```

   - Avoid using `bulk_create` and `bulk_update` when `save()` logic or signals are required.  

8. **What are the advantages of using Django's asynchronous ORM introduced in version 4.1?**  

   The asynchronous Django ORM allows non-blocking database operations, improving performance, especially with slow data sources or high-load systems. The syntax is similar to synchronous operations but uses the `await` keyword:  

   ```python
   async def get_blog(request):
       blog = await Blog.objects.aget(id=10)
       return JsonResponse({'title': blog.title})
   ```

   This enhances server resource utilization and improves application scalability.  

# Essay Topics  

1. **Comparison of query optimization methods in Django ORM and their impact on application performance.**  
2. **The role and management of migrations in team-based Django development: best practices and potential challenges.**  
3. **Using asynchronous Django ORM: advantages, limitations, and examples of integration into existing projects.**  
4. **In-depth exploration of model relationships in Django: from simple associations to complex data structures.**  
5. **Practical use of transactions in Django: ensuring data integrity in real-world projects.**  

# Glossary  

1. **Django ORM (Object-Relational Mapping)**: A Django tool for interacting with the database, enabling data manipulation as Python objects while abstracting SQL queries.  
2. **Migrations**: Djangoâ€™s mechanism for managing database schema changes, tracking and applying model modifications.  
3. **`select_related` and `prefetch_related`**: Django ORM methods to optimize queries by reducing database calls when fetching related data.  
4. **Abstract Base Models**: Django models that do not create database tables but can be inherited by other models to reuse fields and methods.  
5. **Indexes**: Database structures that speed up data retrieval by optimizing queries on specific fields.  
6. **Asynchronous ORM**: A new feature in Django 4.1 that enables asynchronous database operations, improving application performance.  
7. **`null` and `blank`**: Parameters in Django model fields that control whether `NULL` is allowed in the database and whether the field can be left empty during data entry.  
8. **Transactions**: A mechanism for executing a set of database operations atomically, ensuring that either all operations succeed or none are applied in case of an error.  
9. **`OneToOneField`, `ForeignKey`, `ManyToManyField`**: Fields in Django models used to define relationships between objects.